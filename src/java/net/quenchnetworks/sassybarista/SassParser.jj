options {
	STATIC = false ;
	UNICODE_INPUT = true ;
}

PARSER_BEGIN(SassParser)
package net.quenchnetworks.sassybarista;

import java.util.*;

import net.quenchnetworks.sassybarista.value.*;

class SassParser {
	public static class ParseResult
	{
		public Map<String, IPropertyValue> variables;
		public Map<String, Mixin> mixins;
		public List<Rule> rules;
	}

	public static void main( String[] args )
	throws ParseException, TokenMgrError {
		SassParser parser = new SassParser( System.in ) ;
		ParseResult result = parser.Start();
		
		for (Rule rule : result.rules) {
			printRule(rule, 0);
		}
	}
	
	public static String padding(int n)
	{
		StringBuilder buffer = new StringBuilder();
		for (int i = 0; i < n; i++) {
			buffer.append("\t");
		}
		
		return buffer.toString();
	}
	
	public static void printRule(Rule rule, int depth)
	{
		String padding = padding(depth);
	
		for (SelectorChain selectorChain : rule.getSelectorChains()) {
			System.out.println(padding + selectorChain.toString());
		}
		
		for (Property property : rule.getProperties()) {
			System.out.print(padding + "\t" + property.getKey() + ": ");
			for (IPropertyValue value : property.getValues()) {
				System.out.print(value + " ");
			}
			System.out.println();				
		}
		
		System.out.println();
		for (Rule subrule : rule.getSubRules()) {
			printRule(subrule, depth+1);
		}
	}
}
PARSER_END(SassParser)

/*TOKEN_MGR_DECLS : {
    int commentNestingDepth ; 
} */

SKIP :
{
  "/*" : WithinComment
}
<WithinComment> SKIP :
{
  "*/" : DEFAULT
}
<WithinComment> MORE :
{
  <~[]>
}

//SKIP : { " " }
//SKIP : { "\t" | "\n" | "\r" | "\r\n" }
//SKIP : {  "/*" { commentNestingDepth = 1 ; } : COMMENT } 

TOKEN : { < #ident : ("-")? <nmstart> (<nmchar>)* > }
TOKEN : { < #name : (<nmchar>)+ > }
TOKEN : { < #nmstart : ["a"-"z","A"-"Z"] | "_" | <nonascii> | <escape> > }
TOKEN : { < #nonascii : ["\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #unicode : "\\" (["a"-"f","A"-"F","0"-"9"]){1,6} (<wc>)? > }
TOKEN : { < #escape : <unicode> | "\\" ["\u0020"-"\u007E","\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #nmchar : ["a"-"z","A"-"Z","0"-"9"] | "-" | "_" | <nonascii> | <escape> > }
TOKEN : { < #num : (["0"-"9"])+ | (["0"-"9"])* "." (["0"-"9"])+ > }
TOKEN : { < #string : "\"" (<stringchar> | "'")* "\"" | "'" (<stringchar> | "\"")* "'" > }
TOKEN : { < #stringchar : <urlchar> | "\u0020" | "\\" <nl> > }
TOKEN : { < #urlchar : ["\u0009","\u0021","\u0023"-"\u0026","\u0027"-"\u007E"] | <nonascii> | <escape> > }
TOKEN : { < #nl : "\n" | "\r" "\n" | "\r" | "\u000C" > }
TOKEN : { < #wc: "\u0009" | "\n" | "\u000C" | "\r" | "\u0020" > }
TOKEN : { < #w : (<wc>)* > }

TOKEN : { < IDENT : <ident> > }
//TOKEN : { < ATKEYWORD : "@" <ident> > }
TOKEN : { < STRING : <string> > }
TOKEN : { < HASH : "#" <name> > }
TOKEN : { < NUMBER : <num> > }
TOKEN : { < PERCENTAGE : <num> "%" > }
TOKEN : { < DIMENSION : <num> <ident> > }
TOKEN : { < URI : "url(" <w> (<string> | (<urlchar>)* ) <w> ")" > }
TOKEN : { < S : (<wc>)+ > }
TOKEN : { < FUNCTION : <ident> "(" > }
TOKEN : { < INCLUDES : "~=" > }
TOKEN : { < DASHMATCH : "|=" > }
TOKEN : { < PREFIXMATCH : "^=" > }
TOKEN : { < SUFFIXMATCH : "$=" > }
TOKEN : { < SUBSTRINGMATCH : "*=" > }

TOKEN : { < VARIABLE : "$" <name> > }

//MORE : { < DELIMETER : <delim> > }

ParseResult Start() :
{
	Token t ;
	List<Rule> rules ;
	Rule rule ;
	Mixin mixin ;
	Map<String, IPropertyValue> variables ;
	Map<String, Mixin> mixins ;
	String variableName ;
	IPropertyValue variableValue ;
	ParseResult result ;
}
{
	{ 
		rules = new ArrayList<Rule>(); 
		variables = new HashMap<String, IPropertyValue>();
		mixins = new HashMap<String, Mixin>();
	}
	(
		(
			t = <VARIABLE>
			{ variableName = t.image; }
			":"
			(<S>)*
			variableValue = PropertyValue()
			";"
			(<S>)*
			{ variables.put(variableName, variableValue); }
		)
		|
		(
			"@mixin"
			(<S>)+
			mixin = Mixin()
			{ mixins.put(mixin.getName(), mixin); }
		)
		|
		(
			rule = Rule()
			{ rules.add(rule); }
		)
	)+
	{ 
		result = new ParseResult();
		result.variables = variables;
		result.rules = rules;
		result.mixins = mixins;
	
		return result; 
	}
}

Rule Rule() :
{
	Token t ;
	Rule rule;
	SelectorChain selectorChain ;
}
{
	{ rule = new Rule(); }
	(
		selectorChain = SelectorChain()
		{ rule.addSelectorChain(selectorChain); }
	)+
	Block(rule)
	
	{ return rule; }
}

Mixin Mixin() :
{
	Token t ;
	Mixin mixin;
}
{
	{ mixin = new Mixin(); }
	
	(
		(
			t = <IDENT>
			{ mixin.setName(t.image); }
			(<S>)*
		)
		|
		(
			t = <FUNCTION>
			{ mixin.setName(t.image.substring(0, t.image.length()-1)); }
			(<S>)*
				t = <VARIABLE>
				{ mixin.addParameter(t.image); }
				(<S>)*
				(
					","
					(<S>)*
					t = <VARIABLE>
					{ mixin.addParameter(t.image); }
					(<S>)*
				)*
			")"
			(<S>)*
		)
	)

	Block(mixin)
	
	{ return mixin; }
}

void Block(Block block) :
{
	Token t ;
	Rule nestedRule;
	Property property ;
	IncludeDirective i ;
	IPropertyValue value ;
}
{
	"{"
	(<S>)*
	(
		LOOKAHEAD( <IDENT> ":" )
		(
			t = <IDENT>
			":"
			(<S>)*
			{ property = new Property(t.image); }
			(
				value = PropertyValue()
				{ property.addValue(value); }
				(",")?
				(<S>)*
			)+
			";"
			(<S>)*
			{ block.addProperty(property); }
		)
		|
		(
			"@include"
			(<S>)+
			(
				(
					t = <IDENT>
					{ i = new IncludeDirective(t.image); }
				)
				|
				(
					t = <FUNCTION>
					{ i = new IncludeDirective(t.image.substring(0, t.image.length()-1)); }
					value = PropertyValue()
					{ i.addParameter(value); }
					(<S>)*
					(
						","
						(<S>)*
						value = PropertyValue()
						{ i.addParameter(value); }
						(<S>)*
					)*
					")"
				)
			)
			";"
			(<S>)*
			
			{ block.addInclude(i); }
		)
		|
		(
			nestedRule = Rule()
			{ block.addSubRule(nestedRule); }
		)
	)*
	"}"
	(<S>)*
}

SelectorChain SelectorChain() :
{
	Token t ;
	Selector s ;
	SelectorChain selectorChain ;
}
{
	{ selectorChain = new SelectorChain(); }
	(
		LOOKAHEAD(1)
		s = Selector()
		{ selectorChain.addSelector(s); }
	)+
	(",")?
	(<S>)*
	
	{ return selectorChain; }
}

Selector Selector() :
{
	Token t ;
	Selector s ;
	Selector.AttributeSelector attr ;
}
{
	{ s = new Selector(); }
	
	// Combinator
	[
		(
			">"
			{ s.setCombinator(Selector.Combinator.CHILD_OF); }
			|
			"+"
			{ s.setCombinator(Selector.Combinator.DIRECTLY_PRECEDED_BY); }
			|
			"~"
			{ s.setCombinator(Selector.Combinator.PRECEDED_BY); }
		)
		(<S>)+
	]
	
	(
		LOOKAHEAD(2)
		(
			// ID
			t = <HASH>
			{ s.setId(t.image.substring(1)); }
		|
			// Class
			"."
			t = <IDENT>
			{ s.setClassName(t.image); }
		|
			// Element
			t = <IDENT>
			{ s.setElement(t.image); }
		)
	)+
	
	// Pseudo class
	[
		":"
		t = <IDENT>
		{ s.setPseudoClass(t.image); }
		(
			"("
			t = <IDENT>
			{ s.setPseudoClassParameter(t.image); }
			")"
		)*
	]
	
	// Attribute selector
	[
		{ attr = new Selector.AttributeSelector(); }
		"["
		t = <IDENT>
		{ attr.setAttribute(t.image); }
		(
			(
				"="
				{ attr.setType(Selector.AttributeSelectorType.EQUAL); }
				|
				<INCLUDES>
				{ attr.setType(Selector.AttributeSelectorType.INCLUDES); }
				|
				<PREFIXMATCH>
				{ attr.setType(Selector.AttributeSelectorType.PREFIXMATCH); }
				|
				<SUFFIXMATCH>
				{ attr.setType(Selector.AttributeSelectorType.SUFFIXMATCH); }
				|
				<SUBSTRINGMATCH>
				{ attr.setType(Selector.AttributeSelectorType.SUBSTRINGMATCH); }
				|
				<DASHMATCH>
				{ attr.setType(Selector.AttributeSelectorType.DASHMATCH); }
			)
			t = <STRING>
			{ attr.setValue(t.image.substring(1,t.image.length()-1)); }
		)*
		"]"
		{ s.setAttributeSelector(attr); }
	]
	
	(LOOKAHEAD(1) <S>)*
	
	{ return s; }
}

IPropertyValue PropertyValue() :
{
	Token t ;
	IPropertyValue p ;
	IPropertyValue tmp ;
	FunctionPropertyValue fp ;
}
{
	(
			t = <IDENT> 
			{ p = new DefaultPropertyValue(t.image); } 
		|
			t = <NUMBER> 
			{ p = new NumberPropertyValue(t.image); } 
		|
			t = <PERCENTAGE> 
			{ p = new PercentagePropertyValue(t.image); } 
		|
			t = <DIMENSION> 
			{ p = new DimensionPropertyValue(t.image); } 
		|
			t = <STRING> 
			{ p = new StringPropertyValue(t.image); } 
		|
			t = <URI> 
			{ p = new URIPropertyValue(t.image); } 
		|
			t = <HASH> 
			{ p = new ColorPropertyValue(t.image); } 
		|
			t = <VARIABLE>
			{ p = new VariablePropertyValue(t.image); }
		|
			t = <FUNCTION> 
			{ fp = new FunctionPropertyValue(t.image.substring(0,t.image.length()-1)); } 
			(<S>)* 
			(
				tmp = PropertyValue() 
				{ fp.addValue(tmp); }
				(<S>)*
			)* 
			")"
			{ p = fp; }
	)
	
	{ return p; }
}
