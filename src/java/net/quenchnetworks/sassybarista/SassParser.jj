options {
	STATIC = false ;
}

PARSER_BEGIN(SassParser)
package net.quenchnetworks.sassybarista;

import java.util.*;

class SassParser {
	public static class ParseResult
	{
		public Map<String, String> variables;
		public List<Rule> rules;
	}

	public static void main( String[] args )
	throws ParseException, TokenMgrError {
		SassParser parser = new SassParser( System.in ) ;
		ParseResult result = parser.Start();
		
		for (Rule rule : result.rules) {
			printRule(rule, 0);
		}
	}
	
	public static String padding(int n)
	{
		StringBuilder buffer = new StringBuilder();
		for (int i = 0; i < n; i++) {
			buffer.append("\t");
		}
		
		return buffer.toString();
	}
	
	public static void printRule(Rule rule, int depth)
	{
		String padding = padding(depth);
	
		for (Selector selector : rule.getSelectors()) {
			System.out.println(padding + selector.toString());
		}
		
		for (Property property : rule.getProperties()) {
			System.out.print(padding + "\t" + property.getKey() + ": ");
			for (String value : property.getValues()) {
				System.out.print(value + " ");
			}
			System.out.println();				
		}
		
		System.out.println();
		for (Rule subrule : rule.getSubRules()) {
			printRule(subrule, depth+1);
		}
	}
}
PARSER_END(SassParser)

/*TOKEN_MGR_DECLS : {
    int commentNestingDepth ; 
} */

SKIP :
{
  "/*" : WithinComment
}
<WithinComment> SKIP :
{
  "*/" : DEFAULT
}
<WithinComment> MORE :
{
  <~[]>
}

SKIP : { " " }
SKIP : { "\t" | "\n" | "\r" | "\r\n" }
//SKIP : {  "/*" { commentNestingDepth = 1 ; } : COMMENT } 

TOKEN : { < #ident : ("-")? <nmstart> (<nmchar>)* > }
TOKEN : { < #name : (<nmchar>)+ > }
TOKEN : { < #nmstart : ["a"-"z","A"-"Z"] | "_" | <nonascii> | <escape> > }
TOKEN : { < #nonascii : ["\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #unicode : "\\" (["a"-"f","A"-"F","0"-"9"]){1,6} (<wc>)? > }
TOKEN : { < #escape : <unicode> | "\\" ["\u0020"-"\u007E","\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #nmchar : ["a"-"z","A"-"Z","0"-"9"] | "-" | "_" | <nonascii> | <escape> > }
TOKEN : { < #num : (["0"-"9"])+ | (["0"-"9"])* "." (["0"-"9"])+ > }
TOKEN : { < #string : "\"" (<stringchar> | "'")* "\"" | "'" (<stringchar> | "\"")* "'" > }
TOKEN : { < #stringchar : <urlchar> | "\u0020" | "\\" <nl> > }
TOKEN : { < #urlchar : ["\u0009","\u0021","\u0023"-"\u0026","\u0027"-"\u007E"] | <nonascii> | <escape> > }
TOKEN : { < #nl : "\n" | "\r" "\n" | "\r" | "\u000C" > }
TOKEN : { < #wc: "\u0009" | "\n" | "\u000C" | "\r" | "\u0020" > }
TOKEN : { < #w : (<wc>)* > }
TOKEN : { < #delim : "." > }

TOKEN : { < IDENT : <ident> > }
TOKEN : { < STRING : <string> > }
TOKEN : { < HASH : "#" <name> > }
TOKEN : { < NUMBER : <num> > }
TOKEN : { < PERCENTAGE : <num> "%" > }
TOKEN : { < DIMENSION : <num> <ident> > }
TOKEN : { < URI : "url(" <w> (<string> | (<urlchar>)* ) <w> ")" > }

TOKEN : { < COLON : ":" > }
TOKEN : { < VARIABLE : "$" <name> > }

MORE : { < DELIMETER : <delim> > }

ParseResult Start() :
{
	Token t ;
	List<Rule> rules ;
	Rule rule ;
	Map<String, String> variables ;
	String variableName ;
	String variableValue ;
	ParseResult result ;
}
{
	{ 
		rules = new ArrayList<Rule>(); 
		variables = new HashMap<String, String>();
	}
	(
		(
			t = <VARIABLE>
			{ variableName = t.image; }
			":"
			variableValue = Any()
			";"
			{ variables.put(variableName, variableValue); }
		)
		|
		(
			rule = Rule()
			{ rules.add(rule); }
		)
	)*
	{ 
		result = new ParseResult();
		result.variables = variables;
		result.rules = rules;
	
		return result; 
	}
}

Rule Rule() :
{
	Token t ;
	Rule rule;
	Rule nestedRule;
	Selector selector ;
	Property property ;
	String result ;
}
{
	{ rule = new Rule(); }
	(
		selector = Selector()
		{ rule.addSelector(selector); }
	)+
	"{"
	(
		LOOKAHEAD( <IDENT> ":" )
		(
			t = <IDENT>
			":"
			{ property = new Property(t.image); }
			(
				result = Any()
				{ property.addValue(result); }
				(",")*
			)+
			";"
			{ rule.addProperty(property); }
		)
		|
		(
			nestedRule = Rule()
			{ rule.addSubRule(nestedRule); }
		)
	)*
	"}"
	
	{ return rule; }
}

Selector Selector() :
{
	Token t ;
	String result ;
	Selector selector ;
}
{
	{ selector = new Selector(); }
	(
		result = Any()
		{ selector.addSelectorRule(result); }
	)+
	(",")?
	
	{ return selector; }
}

String Any() :
{
	Token t ;
}
{
	(
		t = <IDENT> |
		t = <HASH> |
		t = <NUMBER> |
		t = <PERCENTAGE> |
		t = <DIMENSION> |
		t = <STRING> |
		t = <COLON> | 
		t = <URI>
	)
	
	{ return t.image; }
}
