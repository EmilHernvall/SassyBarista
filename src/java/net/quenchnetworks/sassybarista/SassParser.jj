options {
	STATIC = false ;
}

PARSER_BEGIN(SassParser)
package net.quenchnetworks.sassybarista;

import java.util.*;

class SassParser {
	public static class ParseResult
	{
		public Map<String, String> variables;
		public List<Rule> rules;
	}

	public static void main( String[] args )
	throws ParseException, TokenMgrError {
		SassParser parser = new SassParser( System.in ) ;
		ParseResult result = parser.Start();
		
		for (Rule rule : result.rules) {
			printRule(rule, 0);
		}
	}
	
	public static String padding(int n)
	{
		StringBuilder buffer = new StringBuilder();
		for (int i = 0; i < n; i++) {
			buffer.append("\t");
		}
		
		return buffer.toString();
	}
	
	public static void printRule(Rule rule, int depth)
	{
		String padding = padding(depth);
	
		for (SelectorChain selectorChain : rule.getSelectorChains()) {
			System.out.println(padding + selectorChain.toString());
		}
		
		for (Property property : rule.getProperties()) {
			System.out.print(padding + "\t" + property.getKey() + ": ");
			for (String value : property.getValues()) {
				System.out.print(value + " ");
			}
			System.out.println();				
		}
		
		System.out.println();
		for (Rule subrule : rule.getSubRules()) {
			printRule(subrule, depth+1);
		}
	}
}
PARSER_END(SassParser)

/*TOKEN_MGR_DECLS : {
    int commentNestingDepth ; 
} */

SKIP :
{
  "/*" : WithinComment
}
<WithinComment> SKIP :
{
  "*/" : DEFAULT
}
<WithinComment> MORE :
{
  <~[]>
}

//SKIP : { " " }
//SKIP : { "\t" | "\n" | "\r" | "\r\n" }
//SKIP : {  "/*" { commentNestingDepth = 1 ; } : COMMENT } 

TOKEN : { < #ident : ("-")? <nmstart> (<nmchar>)* > }
TOKEN : { < #name : (<nmchar>)+ > }
TOKEN : { < #nmstart : ["a"-"z","A"-"Z"] | "_" | <nonascii> | <escape> > }
TOKEN : { < #nonascii : ["\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #unicode : "\\" (["a"-"f","A"-"F","0"-"9"]){1,6} (<wc>)? > }
TOKEN : { < #escape : <unicode> | "\\" ["\u0020"-"\u007E","\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #nmchar : ["a"-"z","A"-"Z","0"-"9"] | "-" | "_" | <nonascii> | <escape> > }
TOKEN : { < #num : (["0"-"9"])+ | (["0"-"9"])* "." (["0"-"9"])+ > }
TOKEN : { < #string : "\"" (<stringchar> | "'")* "\"" | "'" (<stringchar> | "\"")* "'" > }
TOKEN : { < #stringchar : <urlchar> | "\u0020" | "\\" <nl> > }
TOKEN : { < #urlchar : ["\u0009","\u0021","\u0023"-"\u0026","\u0027"-"\u007E"] | <nonascii> | <escape> > }
TOKEN : { < #nl : "\n" | "\r" "\n" | "\r" | "\u000C" > }
TOKEN : { < #wc: "\u0009" | "\n" | "\u000C" | "\r" | "\u0020" > }
TOKEN : { < #w : (<wc>)* > }

TOKEN : { < IDENT : <ident> > }
TOKEN : { < ATKEYWORD : "@" <ident> > }
TOKEN : { < STRING : <string> > }
TOKEN : { < HASH : "#" <name> > }
TOKEN : { < NUMBER : <num> > }
TOKEN : { < PERCENTAGE : <num> "%" > }
TOKEN : { < DIMENSION : <num> <ident> > }
TOKEN : { < URI : "url(" <w> (<string> | (<urlchar>)* ) <w> ")" > }
TOKEN : { < S : (<wc>)+ > }
TOKEN : { < FUNCTION : <ident> "(" > }
TOKEN : { < INCLUDES : "~=" > }
TOKEN : { < DASHMATCH : "|=" > }
TOKEN : { < PREFIXMATCH : "^=" > }
TOKEN : { < SUFFIXMATCH : "$=" > }
TOKEN : { < SUBSTRINGMATCH : "*=" > }

TOKEN : { < VARIABLE : "$" <name> > }

//MORE : { < DELIMETER : <delim> > }

ParseResult Start() :
{
	Token t ;
	List<Rule> rules ;
	Rule rule ;
	Map<String, String> variables ;
	String variableName ;
	String variableValue ;
	ParseResult result ;
}
{
	{ 
		rules = new ArrayList<Rule>(); 
		variables = new HashMap<String, String>();
	}
	(
		(
			t = <VARIABLE>
			{ variableName = t.image; }
			":"
			(<S>)*
			variableValue = Any()
			";"
			(<S>)*
			{ variables.put(variableName, variableValue); }
		)
		|
		(
			rule = Rule()
			{ rules.add(rule); }
		)
	)+
	{ 
		result = new ParseResult();
		result.variables = variables;
		result.rules = rules;
	
		return result; 
	}
}

Rule Rule() :
{
	Token t ;
	Rule rule;
	Rule nestedRule;
	SelectorChain selectorChain ;
	Property property ;
	String result ;
}
{
	{ rule = new Rule(); }
	(
		selectorChain = SelectorChain()
		{ rule.addSelectorChain(selectorChain); }
	)+
	"{"
	(<S>)*
	(
		LOOKAHEAD( <IDENT> ":" )
		(
			t = <IDENT>
			":"
			(<S>)*
			{ property = new Property(t.image); }
			(
				result = Any()
				{ property.addValue(result); }
				(",")?
				(<S>)*
			)+
			";"
			(<S>)*
			{ rule.addProperty(property); }
		)
		|
		(
			nestedRule = Rule()
			{ rule.addSubRule(nestedRule); }
		)
	)*
	"}"
	(<S>)*
	
	{ return rule; }
}

SelectorChain SelectorChain() :
{
	Token t ;
	Selector s ;
	SelectorChain selectorChain ;
}
{
	{ selectorChain = new SelectorChain(); }
	(
		LOOKAHEAD(1)
		s = Selector()
		{ selectorChain.addSelector(s); }
	)+
	(",")?
	(<S>)*
	
	{ return selectorChain; }
}

Selector Selector() :
{
	Token t ;
	Selector s ;
	Selector.AttributeSelector attr ;
}
{
	{ s = new Selector(); }
	
	// Combinator
	(
		(
			">"
			{ s.setCombinator(Selector.Combinator.CHILD_OF); }
			|
			"+"
			{ s.setCombinator(Selector.Combinator.DIRECTLY_PRECEDED_BY); }
			|
			"~"
			{ s.setCombinator(Selector.Combinator.PRECEDED_BY); }
		)
		(<S>)+
	)?
	
	(
		LOOKAHEAD(2)
		(
			// ID
			t = <HASH>
			{ s.setId(t.image.substring(1)); }
		|
			// Class
			"."
			t = <IDENT>
			{ s.setClassName(t.image); }
		|
			// Element
			t = <IDENT>
			{ s.setElement(t.image); }
		)
	)+
	
	// Pseudo class
	(
		":"
		t = <IDENT>
		{ s.setPseudoClass(t.image); }
		(
			"("
			t = <IDENT>
			{ s.setPseudoClassParameter(t.image); }
			")"
		)*
	)?
	
	// Attribute selector
	(
		{ attr = new Selector.AttributeSelector(); }
		"["
		t = <IDENT>
		{ attr.setAttribute(t.image); }
		(
			(
				"="
				{ attr.setType(Selector.AttributeSelectorType.EQUAL); }
				|
				<INCLUDES>
				{ attr.setType(Selector.AttributeSelectorType.INCLUDES); }
				|
				<PREFIXMATCH>
				{ attr.setType(Selector.AttributeSelectorType.PREFIXMATCH); }
				|
				<SUFFIXMATCH>
				{ attr.setType(Selector.AttributeSelectorType.SUFFIXMATCH); }
				|
				<SUBSTRINGMATCH>
				{ attr.setType(Selector.AttributeSelectorType.SUBSTRINGMATCH); }
				|
				<DASHMATCH>
				{ attr.setType(Selector.AttributeSelectorType.DASHMATCH); }
			)
			t = <STRING>
			{ attr.setValue(t.image.substring(1,t.image.length()-1)); }
		)*
		"]"
		{ s.setAttributeSelector(attr); }
	)?
	
	(LOOKAHEAD(1) <S>)*
	
	{ return s; }
}

String Any() :
{
	Token t ;
	String res ;
	String tmp ;
}
{
	(
		t = <IDENT> { res = t.image; } |
		t = <NUMBER> { res = t.image; } |
		t = <PERCENTAGE> { res = t.image; } |
		t = <DIMENSION> { res = t.image; } |
		t = <STRING> { res = t.image; } |
		t = <URI> { res = t.image; } |
		t = <HASH> { res = t.image; } |
		t = <FUNCTION> 
		{ res = t.image; } 
		(<S>)* 
		(
			tmp = Any() 
			{ res += tmp; }
		)* 
		")"
		{ res += ")"; }
	)
	
	{ return res; }
}
